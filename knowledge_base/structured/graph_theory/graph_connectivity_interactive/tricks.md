# 《图上的游戏》命题报告

**Author:** 左骏驰

### 关键思想与技巧

#### 1. **生成树的构造（O(n log m)）**
- 利用二分查找思想逐步扩展连通性：依次加入顶点1到n−1，对每个新顶点u，使用二分法找出最短前缀的未标记边集合，使得删除该前缀后仍能保持0与u连通。
- 实际上是模拟Kruskal或Prim过程中的“桥”检测：若删去某边导致0无法到达u，则该边必须保留（即为生成树的一部分）。
- 每轮最多进行O(log m)次查询，共n轮，总复杂度O(n log m)。

#### 2. **树转链划分（轻重链思想简化版）**
- 将树以0为根转化为有根树，并将其划分为若干条链，每条链的顶端父亲属于编号更小的链。
- 维护已知链的信息，逐个加入节点：
  - 若当前节点已在已有链中 → 二分确定其所在链编号；
  - 否则 → 使用分治方法找出从0到该点路径上的所有未标记边（这些边构成一条新链）。
- 这种划分方式允许我们递归地、按链顺序求解整棵树结构。

#### 3. **链结构内部排序（类二分插入 + 边定位）**
- 对于每条链，采用随机化+二分插入策略确定点的相对顺序：
  - 随机打乱待插入点顺序，逐个插入当前链序列；
  - 使用二分法在现有链中找到插入位置（通过保留部分边查连通性）；
  - 插入后，在相邻两点间的边上暴力判断每条边位于新点左侧还是右侧（删边测试连通性）。
- 借助随机性分析期望代价：第i步平均影响O(n/i)条边，总期望复杂度O(n log n)。

#### 4. **DFS序的应用与二分定位父节点**
- 在已知低编号链结构的前提下，确定新链顶端的父亲：
  - 所有点按DFS序编号；
  - 二分搜索父亲的DFS序mid，保留所有端点DFS序≤mid的树边以及候选非树边；
  - 查询0能否到达新链顶端 → 决定父亲是否在前半段。
- 正确性依赖于性质：若v是u祖先，则id[v] ≤ id[u]，因此保留DFS序≤mid的所有边可保证子图包含所有对应顶点且连通。

#### 5. **非树边恢复（两种O(m log m)方法）**

##### 方法一（自底向上剥叶子）：
- 按照生成树的叶子顺序逐步删除叶子u：
  - 删除u与其父之间的树边；
  - 使用分治法（见2.3节）找出所有与u相连的边（“好边”）；
  - 对每条连接u的非树边ei，通过在剩余树的DFS序上二分，确定另一端点。
- 因每次只关注一个固定端点，只需一次二分即可定位另一个端点，常数较小。

##### 方法二（枚举树边跨连通块）：
- 枚举每条树边(u,v)，删除后形成两个连通块C1（含u）、C2（含v）；
- 使用分治法找出所有跨过C1-C2割的非树边（即两端分别在C1和C2的边）；
- 对每条这样的非树边e，分别在C1和C2内对其端点做DFS序二分，精确定位两个端点；
- 每条非树边至少被一条树边分割，故最终能全部找到。

> 注：方法一是方法二在特定边序（剥叶顺序）下的优化版本，利用了固定一端的优势减少二分次数。

#### 6. **分治找“好元素”模板（核心交互技巧）**
- 问题：从N个元素中找出M个“好”元素，仅能询问某集合是否有好元素。
- 解法：分治区间[left, right]，若左半有好元素则递归左半，右半同理。
- 复杂度O(M log N)，因为每个好元素引发O(log N)次查询。
- 应用于：找路径上的关键边、找与某点相连的所有边等场景。

#### 7. **部分分设计哲学**
- 正解分为三个层次：
  1. 链结构 → 2. 树结构 → 3. 一般连通图；
- 每个阶段提供相应分数，鼓励渐进思考；
- 设计理念：避免强依赖顺序（如必须A→B→C），允许跳跃式突破但奖励系统性理解；
- 提高区分度：不同思维深度获得不同分数。