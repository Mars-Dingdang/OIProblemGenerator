- **性质7**: 树上距离公式：`d(u,v) = h(u) + h(v) - 2*h(LCA(u,v))`，常用于距离查询。
- **倍增优化**: 预处理 `fa[x][i]` 表示 x 的第 $2^i$ 祖先，可将跳跃复杂度降至 $O(\log n)$。
- **Cache优化**: 将倍增数组定义为 `fa[LOG][MAXN]` 而非 `fa[MAXN][LOG]` 可减少 cache miss。
- **欧拉序列转化**: LCA 问题可转化为 RMQ 问题。对树进行 DFS 得到欧拉序列（长度 $2n-1$），则 $\text{LCA}(u,v)$ 对应区间 $[\min(pos[u],pos[v]), \max(pos[u],pos[v])]$ 中深度最小的节点。
- **±1 RMQ**: 欧拉序列中相邻节点深度差为 ±1，可用块状预处理 + ST 表实现 $O(n)$ 预处理、$O(1)$ 查询的 RMQ，从而得到线性复杂度的 LCA。
- **Tarjan离线技巧**: 使用并查集在 DFS 回溯时标记已访问节点，若查询点已被访问，则其 LCA 为当前并查集的根。注意此法虽常用，但严格线性需参考 Gabow-Tarjan 论文。
- **树链剖分应用**: LCA 发生在两条链第一次进入同一条重链时，取深度较小者。查询快且常数小。
- **Link-Cut Tree**: 两次 `access(u)` 和 `access(v)` 后，第二次返回的节点即为 LCA。适用于动态树场景。
- **多点LCA**: 多个点的 LCA 可递推计算：$\text{LCA}(S \cup \{v\}) = \text{LCA}(\text{LCA}(S), v)$，结合性质5：$\text{LCA}(A \cup B) = \text{LCA}(\text{LCA}(A), \text{LCA}(B))$。
- **前/后序遍历性质**: LCA 在前序中最先出现，在后序中最后出现，可用于验证或构造题。
- **路径存在性判断**: $u$ 是 $v$ 的祖先当且仅当 $\text{LCA}(u,v) = u$，可用于拓扑或依赖判断。