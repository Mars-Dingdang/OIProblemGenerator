- **Floyd 枚举环的核心思想**：在执行 Floyd 算法时，外层循环到点 $ k $ 时，`dis[i][j]` 表示的是只经过编号小于 $ k $ 的点的最短路径。此时若存在边 $ (i,k) $ 和 $ (k,j) $，则三者与 `dis[i][j]` 可构成一个环：$ i \to k \to j \to \dots \to i $，长度为 `dis[i][j] + g[i][k] + g[k][j]`。

- **避免重复点与非法环**：通过限制 $ i < k, j < i $ 确保 $ i, j, k $ 互不相同，防止自环或两点环（如 $ i-k-i $）被误判。

- **路径还原技巧**：使用 `pos[i][j] = k` 记录最短路 $ i \to j $ 是否经过 $ k $，然后通过递归 `get_path(u, v)` 分解路径 $ u \to k \to v $，直到中间无节点为止。

- **无向图特性的利用**：由于无向图中边双向存在，任意简单环删去一条边后仍保持连通性，可用于基于 Dijkstra 的做法——枚举相邻边删除后求端点间最短路，加上原边权即为候选环长。

- **时间复杂度选择**：
  - $ O(n^3) $：适合稠密图或 $ n \leq 100 $ 的情况，直接用 Floyd。
  - $ O(m(n+m)\log n) $：稀疏图可用 Dijkstra 枚举边删除。
  - 动态删点问题可考虑离线处理或每次重建 Floyd（当 $ q, n \leq 400 $ 时 $ O(qn^3) $ 可接受）。

- **负权边注意事项**：算法假设无负环（否则最小环可能无限小），但允许非负权边；若有负权边需额外判断环的合法性。

- **初始化细节**：邻接矩阵应初始化为无穷大（如 `0x3f3f3f3f`），对角线为 0，并在读入时取重边最小值。