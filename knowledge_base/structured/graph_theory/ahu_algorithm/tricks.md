### 关键观察与技巧

- **树同构的转化**：无根树同构可以通过树的重心转化为有根树同构问题。若两棵树的重心数量不同，则直接不同构；否则，分别以重心为根进行同构判断。

- **重心性质**：
  - 树的重心最多有两个。
  - 若有两个重心，则它们相邻，且删除连接边后每部分大小均为 $n/2$。
  - 在判断无根树同构时，只需尝试将一棵树的一个重心与另一棵树的任一重心匹配即可。

- **命名算法（ASSIGN-NAME）原理**：
  - 使用递归方式为每个子树生成一个“名字”（NAME），该名字由其子树的名字按字典序排序后拼接而成。
  - 叶子节点命名为 `(0)`，内部节点为 `(` 子节点名字拼接 `)`。
  - 同构的子树具有相同的名字。

- **优化 AHU 算法**：
  - 避免使用字符串表示 NAME，改用整数标签（tag）代替。
  - 按深度分层处理，从下往上逐层分配标签。
  - 每层中，将子树标签序列排序并去重，用排名作为新标签，保证相同结构获得相同标签。
  - 使用基数排序可将总复杂度降至 $O(n)$，快排实现为 $O(n \log n)$。

- **实现细节**：
  - 使用邻接表建图，并注意编号空间（如两棵树合并处理时偏移 `n`）。
  - `dfs_height` 用于按层收集节点，便于自底向上处理。
  - `subtree_tags[u]` 存储的是节点 `u` 所有子节点的标签序列，用于比较子树结构。

- **扩展应用**：
  - 可用于树的最小表示、树的唯一编码、动态规划去重等场景。
  - 结合哈希可实现快速比较（但需防碰撞），而 AHU 是确定性算法。

- **常见错误规避**：
  - 必须对子树标签排序后再拼接，否则顺序不同会被误判为不同构。
  - 多重心情况必须都尝试匹配，不能只试第一个。