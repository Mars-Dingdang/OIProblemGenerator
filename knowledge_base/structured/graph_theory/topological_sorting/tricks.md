## 关键观察
- **拓扑排序仅适用于 DAG**：若图中有环，则无法得到拓扑序。
- **Kahn 算法**：基于入度 BFS，天然得到一种拓扑序，易于实现。
- **DFS 算法**：利用递归栈记录访问状态，可同时检测环并得到逆后序（reverse postorder）作为拓扑序。

## 优化与变种
1. **字典序最小拓扑序**：将队列换成优先队列（小根堆），每次取编号最小的入度为 0 的节点。
2. **统计拓扑序方案数**：在 DAG 上使用 DP，`dp[mask]` 表示已选节点集合为 `mask` 的方案数，复杂度 O(n·2ⁿ)。
3. **求最长/最短路**：先拓扑排序，然后按拓扑序 DP：`dist[v] = min/max(dist[v], dist[u] + w(u,v))`。
4. **关键路径（AOE 网）**：
   - 按拓扑序递推 **最早发生时间**：`ve[v] = max(ve[u] + w(u,v))`。
   - 按逆拓扑序递推 **最迟发生时间**：`vl[u] = min(vl[v] - w(u,v))`。
   - 关键活动满足 `e(u,v) = l(u,v)`，其中 `e = ve[u]`, `l = vl[v] - w(u,v)`。

## 常见转换
- **环检测**：若拓扑排序输出的节点数 < n，则图中有环。
- **分层拓扑**：在 BFS 过程中记录每个节点的拓扑层（距离起点的最长路径边数）。
- **最小拓扑序**：若要求输出拓扑序的字典序最小，使用优先队列。
- **并行执行**：在 Kahn 算法中，每一轮入度为 0 的节点可以并行执行（模拟任务调度）。

## 注意点
- 初始化入度数组时需遍历所有边。
- 当图不连通时，需对每个未访问节点启动 DFS/BFS。
- 若需多次拓扑排序（如图动态添加边），可维护入度数组并增量更新。