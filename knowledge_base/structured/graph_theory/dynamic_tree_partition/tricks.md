## Key Observations
1. **点分树 (Centroid Tree) 性质**: 点分树深度为 O(log n)，每个节点在点分树上的祖先数量为 O(log n)。
2. **路径分解**: 树上任意路径可以分解为点分树上两个节点的路径，经过它们的 LCA。
3. **重复计算消除**: 对于每个分治中心，需要维护两种信息：
   - 到当前中心的信息
   - 到父中心的信息（用于消除重复）

## 优化技巧
1. **可删堆 (Removable Heap)**: 使用两个优先队列实现可删除的最大堆，用于维护动态集合的最大值。
2. **距离预处理**: 预处理每个节点到点分树祖先的距离，避免每次查询都计算 LCA。
3. **动态开点线段树**: 当权值范围较大时，使用动态开点权值线段树维护距离信息。

## 常见问题转化
1. **最远黑点距离**: 维护每个节点的可删堆，存储所有黑点到该节点的距离，用另一个堆维护答案。
2. **距离限制查询**: 对于查询距离节点 x 不超过 y 的权值和，在点分树上跳祖先，用容斥原理减去重复部分。
3. **点权修改**: 在点分树上暴力跳祖先更新信息，复杂度 O(log n)。

## 注意事项
1. 点分树构建时，第二次 calcsiz 必须使用 `maxx[x] < maxx[rt]` 而不是 `<=`，保证重心不改变。
2. 一个节点到其点分树祖先的距离不一定递增，不能累加计算。
3. 更新操作时要同时维护 dist 和 ch 两个结构，确保信息一致。