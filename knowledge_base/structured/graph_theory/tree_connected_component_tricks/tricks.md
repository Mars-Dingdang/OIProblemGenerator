# 解决树上连通块问题的一些技巧和工具

**Author:** 任轩笛

## 树上连通块DP问题

### 按DFS序转移与点分治
- 当合并子树状态代价高但添加单点代价低时（如背包），可将自底向上DP转为按DFS序逐个加入节点。
- 对于必须包含根的连通块：设 `dp[i]` 表示考虑DFS序前i个节点的状态。若选第i个点，则转移到 `dp[i+1]`；否则跳过其整个子树，转移到 `dp[j]`（j为其子树右端点+1）。
- 若连通块可不包含根：使用点分治，每次以重心为根计算强制包含重心的方案数，删除重心后递归各连通块。总复杂度从 $O(nm)$ 提升至 $O(nm \log n)$。

### “点数 - 边数” 技巧
- 利用树的性质：非空树满足 `点数 - 边数 = 1`。
- 用于统计多个连通块交集非空的方案数：枚举每个点/边，计算有多少合法连通块包含它，最后用所有点的答案减去所有边的答案，即得总方案数。
- 关键在于将全局依赖转化为独立事件（每个连通块都需包含某点/边），便于DP处理。

### 线段树合并进行整体DP
- 适用于每个点维护大小为m的DP数组，且合并操作是逐位合并的情况。
- 使用线段树存储每个点的DP值，通过线段树合并实现高效子树信息合并。
- 添加一个点的操作是 $O(1)$ 或 $O(\log m)$，合并两棵子树变为线段树合并，均摊复杂度 $O(\text{插入总数} \cdot \log m)$，总复杂度常为 $O(n \log n)$ 或 $O(n \log m)$。

### 链分治维护动态DP
- 应用于支持修改节点信息并快速重新计算答案的动态DP问题。
- 基于轻重链剖分：对每条重链构建数据结构（如线段树），维护链上区间选择的方案数（如F值积之和）及前缀方案数。
- 修改一个点时，影响其祖先所在的 $O(\log n)$ 条重链，在每条链的数据结构中更新并传播变化。
- 可结合LCT实现更灵活的动态轻重链调整，达到 $O(qm \log n)$ 复杂度。

## 树上同色连通块维护问题

### 一般思路
- 极大同色连通块的最浅点（LCA）唯一，信息可维护在该点。
- 每个节点维护两种颜色的信息（如B(x), W(x)），表示当其为对应颜色时作为最浅点的连通块属性。
- 颜色翻转时，只需在父节点处切换贡献来源，避免重构整棵子树。
- 支持多种颜色时，可用k倍常数维护k个二色结构。

### Link Cut Memphis (LCM)
- 支持链修改颜色并维护DFS序上任意信息的LCT-based数据结构。
- 维护两棵树：黑树和白树。新定义下：
  - 同色父子在对应颜色树中连接；
  - 若在白树中为重边，则在黑树中也连接（形成“链树”结构）。
- 引入 `Expose(u)` 操作：将u到其最浅同色祖先路径打通为重链，并同步更新另一棵树的结构。
- 链修改流程：分解为若干到根路径的修改；对每段同色段执行 `Expose`，然后切换两棵树中的虚边连接关系。
- 利用平衡树（如Splay）维护DFS序信息（如括号序列求直径），支持链修改后的快速重构。
- 总复杂度为 $O(n \log^2 n)$，源于每次 `Expose` 带来的 $O(\log n)$ 次LCT操作和平衡树维护。