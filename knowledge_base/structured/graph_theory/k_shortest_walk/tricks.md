- **A* 搜索优化**：使用反向图上从终点 `t` 出发的最短距离作为启发函数 `h(x)`，估价函数为 `f(x) = g(x) + h(x)`，其中 `g(x)` 是从起点到当前点的实际代价。通过优先队列扩展状态 `(x, g(x))`，当第 `k` 次访问 `t` 时即得到第 `k` 短路。

- **剪枝策略**：每个节点最多被扩展 `k` 次，因为前 `k` 条到达该节点的路径已足够生成最终答案，后续状态无需扩展。

- **最短路树与偏离边建模**：在反向图上构建以 `t` 为根的最短路树 `T`。对于非树边 `(u, v)`，定义其“偏离成本”为 `Δ(e) = w + h(v) - h(u)`，表示绕行该边带来的额外代价。

- **路径唯一对应**：任意一条从 `s` 到 `t` 的路径可以唯一分解为最短路路径加上若干满足“祖先条件”的偏离边序列。这些偏离边在最短路树上的起点和终点需满足后继边起点是前驱边终点的祖先。

- **可持久化可并堆优化**：将每个节点的偏离边集合用可持久化可并堆维护，并沿最短路树向下合并。这样每个节点的堆包含其自身及子树中的所有偏离边。

- **高效查询机制**：使用优先队列维护当前可用的堆（代表可能的路径扩展），每次取出最小堆顶，记录答案后，将左右子堆和目标节点处的堆重新插入。避免合并操作，直接拆分堆结构，将复杂度降至 `O(k log k)`。

- **图转化思想**：原问题转化为在新图 `G'` 中求从 `s` 出发的前 `k` 短路径（不要求终止于 `t`），每条路径对应原图中一条到 `t` 的合法路径，总长度为 `h(s) + ΣΔ(e)`。

- **复杂度对比**：朴素 A* 时间复杂度为 `O(km log km)`，而可持久化堆做法为 `O(m log m + k log k)`，显著更优，尤其适用于大 `k` 场景。