- **重心选择**：每次递归选择子树的重心作为根节点，保证递归深度为 $O(\log n)$，总时间复杂度为 $O(n \log n)$。
- **桶清理技巧**：避免使用 `memset` 清空数组，而是记录所有被修改的位置并在之后逐一清零，确保复杂度正确。
- **路径分类处理**：将经过当前根的路径分为两类——以根为端点和不以根为端点，后者可由两条前者路径拼接而成。
- **离线查询优化**：在遍历子树时同步检查所有询问，利用桶（boolean array 或线段树）快速判断补集是否存在。
- **边分治转换**：对于高叉树，可通过添加虚点将其转化为二叉树，从而应用边分治，但通常点分治更通用且易于实现。
- **点分树重构**：基于点分治构建新树结构（点分树），使任意路径最多经过 $O(\log n)$ 个重心，适用于支持修改操作的动态问题。
- **贡献转化思想**：如在颜色统计题中，将“每个点的答案”转化为“每种颜色对答案的贡献”，便于分治合并。
- **两次扫描法**：在统计跨子树路径时，先按顺序处理并累加信息，再逆序处理以避免同一子树内重复统计。