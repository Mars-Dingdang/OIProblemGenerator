## 关键观察
1. **递归结构**：DFS 天然适合递归实现，通过函数调用栈隐式维护搜索路径。
2. **回溯机制**：在返回上一层前恢复状态（如 `visited[i] = false`），这是 DFS 的核心特征。
3. **深度优先**：优先深入一条路径到底，再返回探索其他分支。

## 常见优化技巧
1. **可行性剪枝**：在递归前判断当前选择是否可能达到最终解，提前终止不可能的分支。
2. **最优性剪枝**：记录当前最优解，当部分解已劣于最优解时提前返回。
3. **状态压缩**：对于小规模状态（如 n ≤ 20），可用整数位运算代替 `visited` 数组。
4. **记忆化搜索**：将 `(状态参数)` 映射到计算结果，避免重复计算相同子问题。
5. **迭代加深**：限制搜索深度逐步增加，结合 BFS 和 DFS 的优点。

## 问题转化模式
1. **排列/组合问题**：用 `visited` 数组确保元素不重复使用。
2. **子集问题**：每个元素选/不选，递归时传递下标参数。
3. **图遍历**：递归访问邻居节点，用 `visited` 防止循环。
4. **棋盘类问题**：二维坐标作为状态，方向数组辅助移动。

## 实现细节
- 递归深度过大时考虑栈溢出，可改用显式栈实现迭代 DFS。
- 全局变量需谨慎使用，多组数据时注意重置状态。
- 输出格式要求严格时（如场宽），使用 `setw` 等格式化工具。