## 关键观察与技巧

### 双向同时搜索（双向 BFS）
- **核心思想**：从起点和终点同时进行 BFS，当两端的搜索相遇时停止。
- **优势**：搜索树大小指数级减少（从 b^d 减至 2*b^{d/2}，其中 b 是分支因子，d 是深度）。
- **实现要点**：
  - 使用两个队列和两个距离映射（或访问标记）。
  - 交替扩展两个队列（或每次扩展一层）以保证平衡。
  - 相遇条件：当前扩展的状态在另一端的映射中存在。
- **适用场景**：已知起点和终点的状态空间搜索（如八数码、迷宫最短路径）。

### Meet in the Middle（折半搜索）
- **核心思想**：将整个搜索空间分成两半，分别枚举所有可能，然后合并结果。
- **复杂度**：从 O(2^n) 降至 O(n * 2^{n/2})（通常需要映射来存储和查询前半部分结果）。
- **常见合并方式**：
  - **互补合并**：如开关灯问题，前半段状态与后半段状态互补（即合并后所有位为 1）。
  - **双指针/二分**：对前半部分结果排序，后半部分查询时使用二分查找。
  - **哈希映射**：用 unordered_map 存储前半部分的结果（状态 -> 代价），后半部分查询对应状态。
- **适用场景**：组合问题，n 较小（约 30-40），但暴力枚举会超时。

### 优化技巧
1. **状态表示**：使用位运算、字符串哈希或序列化来压缩状态，便于存储和比较。
2. **对称性剪枝**：如果问题具有对称性，可以只搜索一半状态。
3. **启发式扩展**：在双向 BFS 中，优先扩展队列大小较小的一端以保持平衡。
4. **提前终止**：如果一端搜索到终点，可直接返回结果（双向 BFS 中仍需检查相遇）。
5. **映射选择**：
   - 对于状态数较少的情况，可以使用数组。
   - 对于状态数较多或状态空间稀疏，使用 unordered_map（哈希）或 map（树）。

### 问题转化模式
- **将组合优化转化为状态搜索**：如开关灯问题，每个开关按或不按构成状态，目标状态为全亮。
- **将路径搜索转化为双向 BFS**：当起点和终点都明确，且状态转移可逆时。
- **将大范围枚举折半**：当直接枚举所有子集（或排列）不可行时，分成两半分别枚举再合并。

### 注意事项
- **状态哈希冲突**：自定义状态需要确保哈希函数或比较函数正确。
- **内存限制**：Meet in the Middle 需要存储前半部分的所有结果，需估算内存是否足够。
- **交替扩展策略**：双向 BFS 中，交替扩展一层通常比交替扩展一个节点更高效。