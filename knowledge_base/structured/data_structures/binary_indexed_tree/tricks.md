## 核心思想
- **前缀拆分**：任意前缀 [1, n] 可拆分为 O(log n) 个已知区间（c[x] 管辖的区间）。
- **lowbit 操作**：`lowbit(x) = x & -x`，表示 x 二进制最低位的 1 及其后的 0 组成的数。c[x] 管辖区间为 `[x - lowbit(x) + 1, x]`。

## 关键技巧
1. **区间查询转化为前缀差分**：`query(l, r) = sum(r) - sum(l - 1)`。这是处理区间问题的通用技巧。
2. **支持可差分运算**：运算需满足结合律且可差分（有逆运算），如加法、乘法（模质数）、异或。
3. **区间修改 + 单点查询**：维护差分数组 d[i] = a[i] - a[i-1]，修改 [l, r] 加 v 时 `add(l, v); add(r+1, -v)`，查询 a[x] 即 `sum(x)`。
4. **区间修改 + 区间查询**：使用两个 BIT 分别维护 d[i] 和 d[i] * i。公式：
   `∑ a[i] = (r+1)*∑ d[i] - ∑ (d[i]*i)`，其中求和范围是 [1, r]。
5. **O(n) 建树**：
   ```cpp
   for (int i = 1; i <= n; ++i) {
       tree[i] += a[i];
       int j = i + lowbit(i);
       if (j <= n) tree[j] += tree[i];
   }
   ```
6. **处理不可差分信息（如最大值）**：
   - 方法 1：使用两个 BIT 分别维护前缀最大值和特殊结构（参考论文 *Efficient Range Minimum Queries using Binary Indexed Trees*）。
   - 方法 2：使用拓展树状数组，查询复杂度 O(log² n)。
7. **二维扩展**：
   - 单点修改、子矩阵查询：直接二维 BIT。
   - 子矩阵修改、子矩阵查询：维护四个 BIT 分别存储 d[i][j], d[i][j]*i, d[i][j]*j, d[i][j]*i*j。
8. **离散化配合**：当值域远大于元素个数时，先离散化坐标再使用 BIT（常用于统计逆序对、二维偏序问题）。
9. **求第 k 小/大**：BIT 结合二分搜索，在值域 BIT 上根据前缀和判断。

## 常见问题转化
- **逆序对计数**：离散化后从左到右扫描，查询比当前数大的已出现数量。
- **区间排名**：值域 BIT 维护出现次数，查询前缀和。
- **滑动窗口最值**：可用 BIT 维护最大值（需特殊实现）或改用线段树/单调队列。
- **离线查询**：将查询按右端点排序，配合 BIT 动态维护前缀信息。

## 注意事项
- 树状数组下标通常从 1 开始。
- 树状数组能解决的问题是线段树的子集，但代码更短、常数更小。
- 模数下的乘法需保证每个数有逆元（模数为质数时成立）。
- 对于 gcd、max 等不可差分运算，需要特殊处理或使用线段树。