## 关键技巧与优化

### 1. 哨兵节点（Dummy Node）
- **作用**：简化边界条件处理（空链表、头尾操作）。
- **实现**：创建不存储实际数据的头节点，`head->next`指向第一个真实节点。
- **优势**：插入/删除时无需特殊处理头节点，代码更简洁。

### 2. 快慢指针（Floyd's Cycle Detection）
- **应用**：检测循环链表、寻找链表中点、判断链表是否相交。
- **算法**：快指针每次走两步，慢指针每次走一步。
  - 若相遇则有环；
  - 找中点：快指针到末尾时，慢指针在中点。

### 3. 内存优化技巧
- **池化分配**：预先分配节点数组（`Node pool[MAXN]`），用索引代替指针，减少`new/delete`开销。
- **延迟删除**：标记删除而非立即释放，适用于需要撤销操作的场景。

### 4. 链表反转
- **迭代法**：三指针（prev, curr, next）遍历反转。
- **递归法**：递归到尾部，回溯时反转指针。
- **应用**：回文链表判断、区间反转（LeetCode 92）。

### 5. 链表排序
- **归并排序**：O(n log n) 时间复杂度，稳定且适合链表。
  - 快慢指针找中点分割；
  - 合并两个有序链表。
- **优势**：无需随机访问，空间复杂度 O(1)（递归栈除外）。

### 6. 循环链表技巧
- **约瑟夫问题**：循环链表模拟淘汰过程。
- **轮转调度**：用循环链表实现轮询队列。
- **注意**：遍历时需设置终止条件（回到起点）。

### 7. 双向链表优化
- **LRU缓存**：双向链表 + 哈希表，O(1) 访问和更新。
  - 最近使用的移到头部；
  - 淘汰尾部节点。
- **实现队列/双端队列**：支持两端高效操作。

### 8. 问题转化模式
- **链表判环入口**：检测到环后，将慢指针放回头部，同步前进，相遇点即为入口。
- **相交链表**：遍历两链表得到长度差，长链表先走差值步，再同步前进找交点。
- **深拷贝带随机指针链表**：三次遍历（复制节点、复制随机指针、分离链表）。

### 9. 调试技巧
- **可视化**：画图辅助理解指针变化。
- **边界测试**：空链表、单节点、头尾操作。
- **内存泄漏检查**：确保每个`new`都有对应的`delete`（或使用智能指针）。

### 10. 竞赛中的替代方案
- **数组模拟链表**：用`next[i]`、`prev[i]`数组存储索引，避免动态内存分配，速度更快。
- **应用场景**：静态链表、并查集路径压缩、图邻接表存储。