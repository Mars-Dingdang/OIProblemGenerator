## 关键观察与技巧

### 1. LIFO原则的正确理解
- **当前容器原则**：判断LIFO/FIFO时，只考虑当前在容器内的元素进出顺序
- 示例澄清：如果1入栈→1出栈→2入栈→2出栈，从整体看似乎是FIFO，但实际上每个元素在栈中时都遵循LIFO

### 2. 数组模拟栈的优化技巧
- **使用st[0]存储栈大小**：同时作为栈顶指针，节省一个变量
- **边界检查**：弹栈前必须检查栈非空，避免越界
- **内存预分配**：根据问题规模预分配足够数组大小，避免动态扩容开销

### 3. STL栈的底层容器选择
- **std::deque（默认）**：平衡性好，适合大多数场景
- **std::vector**：内存连续，缓存友好，但扩容时可能复制元素
- **std::list**：无扩容开销，但内存不连续，缓存不友好

### 4. 单调栈技巧
- **用途**：解决「下一个更大/更小元素」类问题
- **模板**：
```cpp
vector<int> nextGreater(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, -1);
    stack<int> st;
    for(int i = 0; i < n; i++) {
        while(!st.empty() && nums[st.top()] < nums[i]) {
            res[st.top()] = nums[i];
            st.pop();
        }
        st.push(i);
    }
    return res;
}
```

### 5. 双栈技巧
- **实现队列**：一个栈用于入队，一个栈用于出队
- **表达式求值**：操作数栈和运算符栈分开处理
- **浏览器历史**：前进栈和后退栈

### 6. 最小栈/最大栈
- **同步栈法**：维护一个同步的最小值栈
- **差值法**：存储与当前最小值的差值，节省空间

### 7. 常见问题转换模式
- **括号匹配**：遇到左括号入栈，右括号时检查栈顶是否匹配
- **递归转迭代**：用栈模拟函数调用栈
- **DFS非递归**：用栈代替递归的系统栈
- **逆波兰表达式**：操作数入栈，遇到运算符弹出计算

### 8. 性能优化
- **批量操作**：STL栈的底层容器选择影响性能
- **内存局部性**：数组模拟栈通常比链表实现更快
- **内联函数**：对于高频调用的push/pop操作，使用内联优化

### 9. 错误避免
- **空栈访问**：top()和pop()前必须检查empty()
- **迭代器失效**：STL栈不提供迭代器，避免尝试遍历
- **多线程安全**：标准栈非线程安全，需要额外同步

### 10. 扩展应用
- **递归深度限制**：用栈实现深递归的迭代版本
- **撤销操作**：用栈记录操作历史实现undo
- **语法分析**：编译器中的语法分析栈
- **页面导航**：Web浏览器中的页面历史栈