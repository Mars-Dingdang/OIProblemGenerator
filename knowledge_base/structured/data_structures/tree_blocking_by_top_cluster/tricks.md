# 浅谈一类树分块的构建算法及其应用

**Author:** 周镇东

### 关键思想与技巧

- **Top Cluster 与 Tree Contraction**：
  - 树簇（cluster）是树上的连通子图，至多有两个界点（boundary nodes），界点间的路径称为簇路径。
  - 通过 rake 和 compress 操作可将整棵树收缩为一个簇，形成深度 O(log n) 的 top tree 结构，作为分块的理论基础。

- **静态树分块构造（基于 DFS 栈）**：
  - 任选根进行 DFS，维护一个栈存储尚未归类的边。
  - 在回溯时判断是否弹栈合并成簇，触发条件有三：
    1. 当前节点是根；
    2. 至少两个子树中已有界点（当前点必须成为新界点）；
    3. 栈中边数超过阈值 B（强制分块）。
  - 弹栈后，将当前节点的子树按贪心方式划分为若干段，每段满足：
    - 边数和 ≤ B；
    - 至多一个子树包含已确定的界点（保证新簇至多两个界点）。
  - 贪心截取极长合法前缀即可保证总簇数 O(n/B)。

- **复杂度证明要点**：
  - 每个簇大小 ≤ B（由构造保证）。
  - 总簇数分析：
    - 类型1（因边数超限）：最多 n/B 次，每次产生一个簇，但可配对使总数 ≤ 2n/B；
    - 类型2&3（因多界点或结束）：对应弹栈事件，总发生次数 ≤ 4n/B；
    - 合计 ≤ 6n/B ⇒ O(n/B)。

- **伪簇（Pseudo-cluster）用于动态维护**：
  - 放宽界点数量限制，仅要求连通边集，便于合并/分裂。
  - 引理：良好伪簇划分（每个界点属于至少两个伪簇）中，界点数 ≤ 伪簇数 a。
  - 可将伪簇转化为标准簇划分（建虚树结构），界点数 ≤ 2a。
  - 分裂引理：大小为 n 的伪簇可分裂为两部分，较小者 ≥ n/3（通过重心分割）。

- **动态维护策略**：
  - 加边：合并两伪簇 → 若大小 > 2B，则分裂至合法（最多2次）；
  - 删边：直接切开 → 若某部分过小，尝试与其邻居合并，再视情况分裂；
  - 每次操作仅影响 O(1) 个伪簇，转化后维护簇结构的时间为 O(B)。
  - 可选择定期重构（如每 O(√n) 次操作）以维持整体结构平衡。

- **应用场景中的优化技巧**：
  - **例题1 & 2（第k小值查询）**：
    - 每个簇维护有序点权数组 + 整体加法标记；
    - 修改时暴力重构端点所在簇（O(B)），其他仅打标记；
    - 查询时暴力提取端点簇内信息，在多个有序数组中二分或使用归并技巧求第k小；
    - 使用指针维护“第一个大于0的位置”可避免二分，优化至 O(1) 移动（适用于 ±1 修改）。

  - **例题3 & 4（距离和统计）**：
    - 利用 dis(a,b) = dep[a] + dep[b] - 2dep[lca] 将问题转为 lca 深度和；
    - 使用莫队二次离线减少链加次数；
    - 树分块用于平衡修改与查询：
      - 修改时在收缩树和簇内做树上前缀和，更新界点贡献；
      - 单次修改 O(B + n/B)，查询 O(1)；
      - 取 B = √n 得 O(n√n)。

  - **例题5（可持久化并查集）**：
    - 将时间轴上的操作建为操作树（operation tree）；
    - 对操作树进行树分块，界点处预处理全局连通性；
    - 内点通过至多 O(√n) 条边变化从界点状态转移，结合 BFS 快速还原连通块；
    - 实现了树上版本的“定期重构”，优于传统序列定期重构。

  - **例题6（线性树上并查集）**：
    - 块大小取 B = ⌊log n⌋；
    - 簇内用位掩码存储 dfn 序下的合并状态；
    - highbit 运算快速找到最近未合并祖先；
    - 收缩树上用普通并查集维护，整体复杂度 O(n + q)。

  - **例题7（L-邻域连通块计数）**：
    - 块大小取 B = L；
    - 利用长链剖分在每个簇内 O(L) 计算 DP 数组 f(x,S)；
    - 在收缩树上通过 rake/compress 风格合并 DP 状态；
    - 总复杂度 O(n)，避免官方做法中的逆元计算，更通用。