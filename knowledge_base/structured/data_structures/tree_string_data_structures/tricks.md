# 一类由数据结构解决的树上字符串问题

**Author:** 李静榕

### 关键思想与技巧

1. **重链剖分与轻边性质**：
   - 任意节点到根路径上的轻边数量不超过 $ \log n $，因此树上路径可被分解为 $ O(\log n) $ 条重链段。
   - 所有轻儿子子树大小总和为 $ O(n \log n) $，可用于势能分析或复杂度摊还。

2. **全局平衡二叉树构造**：
   - 在每条重链上构建以轻子树权重为依据的平衡二叉树，使得分裂后子树权重尽量均衡。
   - 证明关键性质：对于任意非叶节点 $ w $ 及其二级祖先 $ u $，满足 $ 2 \cdot \text{val}(w) \leq \text{val}(u) $，从而保证树高为 $ O(\log n) $。
   - 整体形成重构树，支持高效标记下传与查询，单点祖先路径长度为 $ O(\log n) $。

3. **树上字符串定义与后缀结构类比**：
   - 树上字符串由有根树边带字符构成，子串为 $ (u, v) $ 其中 $ v $ 是 $ u $ 的祖先。
   - 所有从根出发的路径对应传统字符串的所有后缀，可建立类似后缀数组（SA）和后缀树的结构。
   - 利用此结构可解决子串 LCP 查询（转化为 RMQ 或 LCA）。

4. **例题1（研心）中的偏序转化与标记合并**：
   - 将拼接串 $ S_i + T_j $ 的最长奇回文拆分为左、右、中间三部分。
   - 中间回文通过枚举左侧回文后缀并在右侧 trie 上匹配实现，使用二分+哈希加速。
   - 使用 Trie + 虚树 + 树剖将操作转化为三种覆盖标记：
     - 单点赋值
     - 重链区间及其轻子树整体赋值
     - 带深度系数的线性赋值（形如 `depth + k`）
   - 引入带符号系数的标记 $ (val, k) $，支持 max 操作的分配律、结合律，允许归并优化至 $ O(s \log^2 s) $。
   - 通过归并排序替代逐个插入，避免每次二分，优化复杂度。

5. **例题2（子树串计数）——动态维护后缀树叶子集**：
   - 目标是计算每个子树对应的后缀树大小（即本质不同子串数）。
   - 启发式分裂：沿重链向下传递信息，保留重儿子状态，轻儿子递归重建。
   - 维护后缀树的有效叶子集合（按 SA 排名排序），使用 set 管理 DFS 序。
   - 删除叶子时需找替代节点：在 SA 上左右二分出 lcp 大于邻居的区间 $[l, r]$，在线段树上查该区间内最深且仍在子树内的祖先节点作为新叶子。
   - 叶子向上移动模拟：所有叶子向父节点移动一次，可能导致某些叶子成为其他叶子的祖先而消失。
   - 预处理“凋亡事件”：用小根堆维护相邻叶子因 LCA 提升导致的消失事件，set 更新时同步维护相邻对与事件队列。
   - 后缀树节点总数 = 所有叶子深度之和 - 相邻叶子 LCA 深度之和，后者可在事件中维护。

6. **不完整树上后缀树结构的能力边界**：
   - 改进版结构使用树剖维护后缀树叶子，区分运动部分（重链上传）和静止部分（轻子树）。
   - 支持维护：
     - 有效节点数（通过事件删除）
     - 前缀匹配个数（子树大小查询，可拆解为两部分贡献）
   - 不支持涉及运动与静止部分交叉贡献的问题（如 end 节点对深度平方和），因其引发无法快速计算的差卷积。

7. **反例揭示结构局限性**：
   - 当沿着重链向下时，整个后缀数组排名可能发生 $ O(n^2) $ 次剧烈变动，说明直接维护 SA 或整棵后缀树不可行。
   - 变化规律源于密集 end 节点形成的周期性，但稀疏情况仍未知。

8. **未来方向思考**：
   - 尝试维护后缀自动机的变化量（但依赖后缀树结构，可能不可行）。
   - 构建所有向下前缀的 Trie 并（即前缀森林），但结构过于复杂难以维护。