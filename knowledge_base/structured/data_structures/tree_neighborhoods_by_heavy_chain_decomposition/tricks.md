# 浅谈树上邻域问题的一种基于长链剖分的解法

**Author:** 刘海峰

## 关键思想与技巧

### 1. **长链剖分基础**
- 定义节点的**高度**为子树中到该节点最远距离+1。
- 每个节点选择**高度最大的儿子**作为长儿子，其余为短儿子。
- 保留长儿子边形成若干**长链**，关键性质：所有短儿子的高度之和为 $ n - h_{\text{root}} $，保证总处理复杂度线性。

### 2. **邻域类型定义**
- **内邻域**(x, d)：x 子树中距离 ≤ d 的点集。
- **外邻域**(x, d)：x 子树外距离 ≤ d 的点集。
- **链邻域**(x, y, d)（y 是 x 祖先）：在 y 子树但不在 x 子树内，且存在路径上一点到该点距离 ≤ d 的点集。

### 3. **内邻域群信息查询（离线）**
- 对每条长链，暴力预处理每个深度 i 上的权值和（利用短儿子高度小，总和线性）。
- 将树视为由长链主干和挂接的“短儿子信息链”组成，结构总大小 O(n)。
- 使用后缀和优化，支持快速区间求和，避免使用线段树，实现线性处理。

### 4. **跳链操作（Jumping Chains）**
- 核心技巧：将邻域查询 $(x, d)$ 向上跳转至祖先 $y$，使得 $y$ 所在长链长度 $ \times 2 \geq d$，从而限制后续处理范围。
- 跳链可通过 DFS + 栈结构离线完成：对每个深度 d 维护当前应跳至哪条长链。
- 在线版本通过构造辅助树解决：
  - 构造图：每个长链 a 创建 $ \text{len}(a) $ 个节点 $(a,1),\dots,(a,\text{len}(a))$。
  - 若 a 的链顶父节点属于链 b，则 $(a,i)$ 连向 $(b,i+1)$（若存在）。
  - 查询最近祖先满足链长 ≥ k → 转化为树上 k-1 级祖先查询，可用 $O(n)-O(1)$ 技术实现。

### 5. **外邻域与链邻域处理**
- 外邻域 $(x,d)$ 可拆分为：
  - 跳链后得到 $(y,d')$，其中 $y$ 是合适祖先。
  - 外邻域 $(y,d')$ 已预处理（通过容斥：外邻域(y,d−1) + 链邻域(x,y,d−1)）。
  - 加上从 x 到 y 路径上各节点的“旁支”贡献（即非长儿子部分的内邻域）。
- 链邻域类似处理，结合跳链与前缀/后缀合并。

### 6. **半群信息不可减情况的处理**
- 当信息不支持减法（如最大独立集），不能直接做差。
- 解决方案：
  - 构造生成森林，每层对应一个偏移量 $i$，仅当 $g_x \geq i$ 时保留节点 $x$（$g_x$: 短儿子最大高度）。
  - 边表示链邻域转移关系，边权为对应半群信息。
  - 使用懒标记技术维护前缀加信息并支持后缀合并，保证修改总量线性。

### 7. **不可拆解信息的动态规划应用**
- 如“内邻域最大权独立集”问题：
  - 对长链自底向上 DP，状态表示距离链顶 ≤ i 的区域的最大独立集。
  - 每次更新相当于对一段前缀进行修改，并对后续位置乘以转移矩阵（如合并子树信息）。
  - 使用懒标记传递未处理的合并操作，扫描时向后推标记。

### 8. **强制在线处理**
- 关键子问题：**序列前驱查询** —— 给定 $i,x$，找最大 $j \leq i$ 使得 $a_j \geq x$。
- 解法：
  - 建图：每个 $(i,1),\dots,(i,a_i)$ 为节点。
  - $(i,y)$ 连向最大 $z \leq i$ 使得 $(z,y+1)$ 存在。
  - 形成内向树森林，查询变为 $(i,1)$ 的 $x-1$ 级祖先，用 $O(n)-O(1)$ 树上k级祖先算法解决。
- 应用于：
  - 内邻域中查找“下方第一个同列有值点”；
  - 跳链操作中的祖先定位。

### 9. **整体转化框架**
- 所有邻域查询最终被转化为：
  - **序列上的区间半群查询**（如内邻域、外邻域的部分）；
  - **树链上的半群查询**（如链邻域）。
- 配合长链剖分与预处理，实现整体 $O(n + Q)$ 时间复杂度。