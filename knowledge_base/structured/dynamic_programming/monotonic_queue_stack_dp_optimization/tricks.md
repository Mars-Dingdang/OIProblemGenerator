## 核心思想
- **单调队列**：维护一个两端可弹出、队尾可插入的双端队列，保持队列内元素单调（递增/递减），用于高效获取滑动窗口最值。
- **单调栈**：维护一个栈顶可弹出的栈，保持栈内元素单调，用于解决「下一个更大/更小元素」类问题。

## 关键观察
1. **单调性方向**：
   - 求最小值 → 维护单调递增队列/栈（队首最小）。
   - 求最大值 → 维护单调递减队列/栈（队首最大）。
2. **转移方程形式**：DP 转移形如 `dp[i] = max_{j in [L(i), R(i)]} {dp[j] + cost(j, i)}`，且 `L(i)`、`R(i)` 单调不减时，可用单调队列优化。
3. **多重背包转化**：通过分组（按余数 `y = j % w[i]`）将二维转移降为一维，再利用 `G[x][y] = dp'[x][y] - v[i] * x` 的单调性优化。

## 优化技巧
- **空间优化**：使用滚动数组（`dp[2][W]`）减少空间消耗。
- **提前计算**：将常数项（如 `b_i - |a_i - j|`）提到 `max` 外部，简化队列比较逻辑。
- **边界处理**：队列弹出时需同时检查下标范围（`q.front() < L(i)`）和单调性。

## 常见问题模式
1. **滑动窗口最值**：直接维护单调队列，队首即窗口最值。
2. **决策单调性**：若 `dp[i]` 的最优决策点 `j` 随 `i` 增加而单调不减，可用队列维护候选决策。
3. **区间最值查询**：将区间查询转化为多个滑动窗口问题。
4. **优化多重背包**：时间复杂度从 `O(W * sum(k_i))` 降至 `O(nW)`。

## 注意事项
- 队列中存储的是**下标**而非值，比较时需通过下标访问对应 DP 值。
- 单调栈弹出时，被弹出的元素即找到了「下一个更大/更小元素」。
- 对于环形问题，可将数组复制一份接在原数组后，转化为线性问题处理。