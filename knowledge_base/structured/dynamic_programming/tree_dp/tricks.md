## 核心思想
- **递归性质**：利用树的递归结构，通常通过 DFS 进行后序遍历，子节点的信息计算完成后，再更新父节点。
- **状态设计**：一般定义 `dp[u][state]` 表示以节点 `u` 为根的子树，在某种状态 `state` 下的最优解。

## 常见技巧
1. **树上背包**
   - 问题：在树上选择若干节点/边，满足依赖关系（如选课）。
   - 方法：合并子树时使用背包 DP，通常用 `dp[u][j]` 表示在 u 的子树中选 j 个物品的最优值。
   - 优化：滚动数组、倒序枚举容量（类似 0/1 背包）以节省空间。

2. **换根 DP（二次扫描）**
   - 问题：不指定根，需要求出以每个节点为根时的答案（如深度和、距离和）。
   - 步骤：
     1. 第一次 DFS：预处理子树信息（如子树大小 `sz[u]`）。
     2. 第二次 DFS：进行换根转移，公式通常为 `f[v] = f[u] - sz[v] + (n - sz[v])` 等形式。

3. **状态压缩**
   - 对于每个节点的有限状态（如选/不选），用 0/1 表示。

4. **基环树处理**
   - 对于基环树（树加一条边），通常断开环上一条边转化为树问题，然后枚举断边情况。

5. **虚树优化**
   - 当只关心部分关键节点时，构建虚树减少节点数，将复杂度与关键点数相关。

## 经典问题模式
- **最大独立集**：节点不相邻，如“没有上司的舞会”。
- **最小点覆盖**：每条边至少一个端点被选。
- **最小支配集**：每个点要么被选，要么与被选点相邻。
- **树上背包**：依赖关系形成树形结构的选择问题。
- **路径统计**：求树上满足条件的路径数量。
- **换根求值**：以每个节点为根计算某个度量（深度和、距离和）。