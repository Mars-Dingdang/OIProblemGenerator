# 回文树及其应用

**Author:** 翁文涛

### 关键思想与技巧

- **结构设计**：回文树由两棵树组成，根分别为`even`（空串，长度0）和`odd`（虚拟节点，长度-1）。每个节点代表一个唯一的回文子串，其字符串由父节点两端添加字符得到。

- **fail指针**：类比AC自动机，fail指向当前节点对应字符串的最长真回文后缀对应的节点。特别地，`fail[even] = fail[odd] = odd`。

- **节点数线性**：任意字符串的不同回文子串个数不超过其长度 |s|。证明使用归纳法：每次新增字符最多引入一个新回文后缀。

- **增量构造**：在末尾添加字符 c 时，从当前最长回文后缀开始沿 fail 链向上跳，找到第一个满足 `s[pos - len - 1] == c` 的节点 t，则 `ctc` 是新的最长回文后缀。

- **势能分析保证复杂度**：定义势函数为当前最长回文后缀长度。每次插入最多使势能+1，而每次跳 fail 会使势能减1，因此总跳跃次数为 O(|s|)，结合 map 查询得总时间复杂度 O(|s| log Σ)。

- **right集合与出现次数**：记录每个回文串在原串中的右端点集合 right。最终可通过 fail 树上传求并集来统计每个回文串的出现次数（即 |right|），用于计算如“长度×出现次数”的最大值等问题。

- **前后端插入统一性**：由于回文串翻转不变，其回文前缀集合等于回文后缀集合，因此 `fail' = fail`，只需维护最长回文前/后缀即可支持首尾插入。

- **删除操作难点**：基于势能的算法无法支持删除（会被卡成 O(n²)）。解决方法是预处理 `quick[c]` 数组，对每个节点存储其 fail 链中前驱为 c 的最长回文后缀，实现稳定 O(log Σ) 插入。

- **重要子串机制**：为支持删除，引入“重要”概念——若一个回文子串不能向左右扩展，则它是重要的。用计数器维护每个回文串是否仍为某个位置的重要后缀，仅当 imp 和 child 均为0时才删除节点。

- **Trie 上建回文树**：对 Trie 每个节点在其父节点基础上插入字符，总共 O(n) 个不同回文子串。必须使用非势能依赖插入避免退化到 O(n²)。

- **可持久化实现**：基于可持久化数据结构（如可持久化线段树）存储转移和 quick 数组，实现版本控制，单次插入时空复杂度 O(log(|s| + Σ))。

- **反链建模**：在 Country 问题中，将父子与 fail 关系建图，转化为 DAG 最长反链问题，利用 Dilworth 定理转为最小路径覆盖求解。

- **halff 指针优化**：用于快速获取不超过一半长度的最长回文后缀，可在 O(|s|) 总时间内维护，用于递归计算回文指数或病毒合成代价。