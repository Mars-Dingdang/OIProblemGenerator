1. **匹配所有子串**: 构造新字符串 `s = p + '#' + t`，计算Z函数，若 `z[i + |p| + 1] == |p|`，则模式 `p` 在文本 `t` 的位置 `i` 出现。
2. **本质不同子串数**: 增量计算，每次在字符串末尾添加字符 `c`，构造反串 `t`，计算其Z函数最大值 `z_max`，新增子串数为 `|t| - z_max`。
3. **字符串整周期**: 计算Z函数后，找到最小的 `n` 的因数 `i` 满足 `i + z[i] == n`，则 `i` 为最短整周期长度。
4. **维护最右匹配段**: 算法核心是维护右端点最靠右的Z-box `[l, r]`，利用已计算信息避免重复比较。
5. **与KMP对比**: Z函数计算每个后缀与整个字符串的最长公共前缀，而前缀函数计算每个前缀的最长真border。两者可相互转化，但Z函数更直观用于某些匹配问题。
6. **边界处理**: 注意 `z[0]` 通常定义为0，算法从 `i=1` 开始。