## 关键观察
- **标准构造方法**：先建立所有字符串的字典树，然后通过 BFS 顺序在字典树上构建 SAM。
- **与伪广义 SAM 的区别**：
  - 伪方法 1：用特殊字符连接字符串后建 SAM，可能导致字符集扩大和额外状态。
  - 伪方法 2：每次插入前重置 last 指针，可能导致重复状态和复杂度退化。
- **线性复杂度**：标准方法严格 O(∑|S_i|)，伪方法最坏可能达到 O(k·∑|S_i|)。

## 优化技巧
- **内存复用**：字典树和 SAM 共用 `next` 数组，构建后字典树结构被破坏。若需保留字典树，可分配双倍空间。
- **状态复用检查**：`insertSAM` 中 `if (len[cur]) return cur;` 避免重复处理已构建节点。
- **克隆转移优化**：克隆节点时，只复制已构建的转移（`len[next[q][i]] != 0`），避免复制未访问的字典树边。

## 常见问题转换
- **所有字符串不同子串总数**：对每个状态 i，贡献为 `len[i] - len[link[i]]`，求和即可。
- **多字符串最长公共子串**：
  1. 为每个节点维护一个标记数组 `flag[size]`，记录该状态出现在哪些字符串中。
  2. 插入时在字典树路径节点上标记当前字符串。
  3. 按 `len` 降序（拓扑序）通过后缀链接将标记向上传递。
  4. 找到所有 `flag` 全满且 `len` 最大的状态。
- **出现次数统计**：类似最长公共子串，用计数数组代替标记数组，沿后缀链接累加。

## 注意事项
- 字符集大小 `CHAR_NUM` 需根据题目调整。
- 数组大小 `MAXN` 至少为 2 倍总字符串长度。
- 初始化时 `link[0] = -1`，表示根节点无后缀链接。
- BFS 顺序保证了父节点先于子节点处理，符合 SAM 的 `len` 递增要求。