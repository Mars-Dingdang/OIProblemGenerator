## 关键观察
- **相邻前缀函数值至多增加 1**：π[i+1] ≤ π[i] + 1。
- **失配时的跳转**：当 s[i+1] ≠ s[π[i]] 时，下一个尝试的长度是 π[π[i]-1]（即次长 border）。
- **Border 与周期的关系**：长度为 r 的 border 对应周期 n−r。最小周期为 n−π[n−1]。

## 优化技巧
- **在线计算**：可以逐个字符处理，无需存储整个字符串，只需存储前 M+1 个字符（M 为最大可能前缀函数值）。
- **自动机预计算**：对于固定模式串，可以预先构建转移表 aut[state][char]，将匹配复杂度降至 O(m)（预处理 O(|Σ|n)）。
- **统计前缀出现次数**：
  1. 先统计每个 π[i] 的出现次数。
  2. 从后向前累加：ans[π[i-1]] += ans[i]。
  3. 最后每个前缀加 1（统计自身）。

## 问题转化模式
1. **字符串匹配**：构造 s + '#' + t，计算前缀函数，π[i]=|s| 的位置即为匹配。
2. **本质不同子串计数**：每次添加字符 c，反转 s+c 得到 t~，计算 π_max，新增子串数为 |s|+1−π_max。
3. **字符串压缩**：计算 k = n−π[n−1]。若 k 整除 n，则最短压缩长度为 k，否则为 n。
4. **递归字符串匹配**（如 Gray 字符串）：利用自动机 + 动态规划计算 G[i][j]（状态转移）和 K[i][j]（出现次数）。

## 常见陷阱
- 前缀函数定义中 π[0]=0（空串无真前缀）。
- 分隔符 '#' 必须不在原串中出现。
- 统计前缀出现次数时，最后要 +1 包含前缀本身。
- 自动机构建时，注意处理 i=0 的边界情况。