## 关键观察与优化

1. **基的选择**：算法默认选择第一个移动的点作为基，但可以预先指定基（如 {n, n-1, ..., 1}），使得内层置换只影响前几个元素，简化计算。

2. **陪集代表系存储**：
   - **直接存储**：每个陪集代表元存储为完整置换，访问 O(1)，但空间 O(n²)。适合 n 较小的情况。
   - **Schreier 树**：存储父指针和生成元索引，空间 O(n)，但访问需要 O(n) 时间重建置换。适合 n 大而群小的情况。
   - 实现中常存储**逆置换**，简化乘法运算。

3. **筛选（Sims filter）**：添加新生成元前先用成员判定检查是否已在群中，避免冗余生成元指数爆炸。保证强生成集大小 O(n²)。

4. **增量更新**：添加生成元时，只计算新状态 (δ,s)，避免重复计算轨道。

5. **复杂度权衡**：
   - 直接存储：时间 O(n⁵) 最坏，实际约 O(n⁴)；空间 O(n³)。
   - Schreier 树：时间多一个 n 因子，空间 O(n log|G|)。

6. **成员判定的副产品**：若置换属于群，算法可将其分解为陪集代表元乘积 t_k...t_2t_1，唯一表示。

7. **随机化版本**：Monte Carlo 变体通过随机采样加速，用于大群。

8. **Jerrum 筛**：替代 Sims 筛，可将强生成集大小优化到 O(n)，但实现更复杂。

## 常见问题转换
- **群阶计算**：|G| = Π |T_i|，直接乘轨道长度。
- **成员判定**：递归消去陪集代表元，若最后剩恒等则属于群。
- **构造群元素**：通过基和强生成集可枚举群元素（但阶大时不可行）。
- **子群测试**：对子群生成集运行算法，比较基与轨道。