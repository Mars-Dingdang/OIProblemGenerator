#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Permutation {
    vector<int> p;
    Permutation(int n = 0) : p(n) { for (int i = 0; i < n; ++i) p[i] = i; }
    Permutation(const vector<int>& vec) : p(vec) {}
    int size() const { return p.size(); }
    int operator[](int i) const { return i < p.size() ? p[i] : i; }
    Permutation operator*(const Permutation& rhs) const {
        int n = max(p.size(), rhs.size());
        vector<int> res(n);
        for (int i = 0; i < n; ++i) res[i] = rhs[(*this)[i]];
        return Permutation(res);
    }
    Permutation inv() const {
        vector<int> res(p.size());
        for (int i = 0; i < p.size(); ++i) res[p[i]] = i;
        return Permutation(res);
    }
    bool isIdentity() const {
        for (int i = 0; i < p.size(); ++i) if (p[i] != i) return false;
        return true;
    }
};

struct StabilizerChain {
    int beta;                     // base point
    vector<Permutation> gens;     // generators
    vector<int> orbit;            // fundamental orbit
    vector<Permutation> trans;    // transversal (inverse stored)
    StabilizerChain* next;        // stabilizer of beta
    
    StabilizerChain(int b = -1) : beta(b), next(nullptr) {}
    ~StabilizerChain() { delete next; }
};

bool membershipTest(StabilizerChain* C, Permutation h) {
    while (C && !C->orbit.empty()) {
        int delta = h[C->beta];
        auto it = find(C->orbit.begin(), C->orbit.end(), delta);
        if (it == C->orbit.end()) return false;
        int idx = it - C->orbit.begin();
        Permutation t = C->trans[idx];
        h = h * t.inv();
        C = C->next;
    }
    return h.isIdentity();
}

void extendTransversal(StabilizerChain* C, Permutation t);

void extend(StabilizerChain* C, Permutation g) {
    if (membershipTest(C, g)) return;
    if (!C || C->beta == -1) {
        // find a point moved by g
        for (int i = 0; i < g.size(); ++i) {
            if (g[i] != i) {
                C->beta = i;
                break;
            }
        }
        C->orbit.push_back(C->beta);
        C->trans.push_back(Permutation(g.size())); // identity
    }
    C->gens.push_back(g);
    vector<Permutation> transCopy = C->trans;
    for (auto& t : transCopy) {
        extendTransversal(C, t * g);
    }
}

void extendTransversal(StabilizerChain* C, Permutation t) {
    int gamma = t[C->beta];
    auto it = find(C->orbit.begin(), C->orbit.end(), gamma);
    if (it == C->orbit.end()) {
        C->orbit.push_back(gamma);
        C->trans.push_back(t.inv()); // store inverse
        for (auto& s : C->gens) {
            extendTransversal(C, t * s);
        }
    } else {
        int idx = it - C->orbit.begin();
        Permutation s_prime = t * C->trans[idx]; // t * trans^{-1}
        if (!s_prime.isIdentity()) {
            if (!C->next) C->next = new StabilizerChain();
            extend(C->next, s_prime);
        }
    }
}

StabilizerChain* schreierSims(const vector<Permutation>& generators) {
    if (generators.empty()) return nullptr;
    int n = generators[0].size();
    StabilizerChain* root = new StabilizerChain();
    for (auto& g : generators) {
        extend(root, g);
    }
    return root;
}

long long groupOrder(StabilizerChain* C) {
    long long res = 1;
    while (C && !C->orbit.empty()) {
        res *= C->orbit.size();
        C = C->next;
    }
    return res;
}

int main() {
    // Example: symmetric group S3 generated by (0 1 2) and (0 1)
    vector<Permutation> gens = {
        Permutation({1, 2, 0}), // (0 1 2)
        Permutation({1, 0, 2})  // (0 1)
    };
    StabilizerChain* bsgs = schreierSims(gens);
    cout << "Order of group: " << groupOrder(bsgs) << endl; // 6
    delete bsgs;
    return 0;
}