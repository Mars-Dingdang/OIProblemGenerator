## 关键观察与技巧

### 1. 置换与排列的等价性
- 当集合元素有自然顺序（如 1..n）时，置换（双射）与排列（单行记号）一一对应。
- 置换的复合（乘法）对应排列的连续应用，**顺序从右向左**：
  `(π∘σ)(x) = π(σ(x))`。

### 2. 奇偶性的快速判定
- 置换的奇偶性 = 逆序数的奇偶性。
- 轮换分解中，置换的奇偶性 = `(n - 轮换个数)` 的奇偶性。
- k-轮换的奇偶性 = `(k-1)` 的奇偶性（奇长度轮换为偶置换，偶长度轮换为奇置换）。

### 3. 置换的阶（order）
- 置换的阶 = 所有轮换长度的最小公倍数（LCM）。
- 利用快速幂可高效计算置换的幂 `σ^k`。

### 4. 逆序数计算优化
- **归并排序法**：在合并过程中统计跨越两部分的逆序对，天然 O(n log n)。
- **树状数组法**：需要离散化，从后往前遍历，查询已出现的小于当前值的数量。
- 逆序数奇偶性决定排列的奇偶性，可用于行列式计算等场景。

### 5. 排名与排列的转换（康托展开/Lehmer码）
- **排列 → 排名**：
  1. 计算 Lehmer 码 `L[i] = #{j > i | a[j] < a[i]}`（可用树状数组从后往前维护）。
  2. 排名 = `1 + Σ L[i] * (n-i-1)!`。
- **排名 → 排列**：
  1. 将排名减一，转换为阶乘进制数（Lehmer码）。
  2. 用数据结构（树状数组/线段树）维护未使用元素集合，按 Lehmer 码依次选取第 k 小的未用元素。
- **时间复杂度**：两者均为 O(n log n)，瓶颈在查询第 k 小/排名查询。

### 6. 置换的幂加速
- 将置换分解为不相交轮换，每个轮换独立计算 `σ^k`：在轮换内移动 `k mod len` 步即可。
- 整体复杂度 O(n)，优于直接快速幂模拟 O(n log k)。

### 7. 相邻对换的性质
- 任何置换可表示为一系列相邻对换的乘积（冒泡排序原理）。
- 相邻对换每次改变排列的奇偶性。

### 8. 置换的型（cycle type）应用
- 型 `1^{α1}2^{α2}...n^{αn}` 唯一确定置换（不计轮换顺序）。
- 用于 Pólya 计数、计算置换个数：`n! / (Π i^{αi} * αi!)`。
- 阶 = `LCM{i | αi>0}`，奇偶性 = `Σ (i-1)αi` 的奇偶性。

### 9. 不动点处理
- 1-轮换是不动点，在组合问题中常需单独考虑（如错排问题）。

### 10. 字典序操作
- C++ STL 的 `next_permutation` / `prev_permutation` 可直接生成字典序下一排列。
- 自定义比较规则时，可仿照其算法实现（从后找升序对，交换，反转后缀）。